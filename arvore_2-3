#include <stdio.h>
#include <stdlib.h>

typedef struct No {
    int n;
    int chave[2];
    struct No *filho[3];
} No;

No* criaNo(int chave, No* esq, No* dir) {
    No* novo = (No*)malloc(sizeof(No));
    novo->n = 1;
    novo->chave[0] = chave;
    novo->filho[0] = esq;
    novo->filho[1] = dir;
    novo->filho[2] = NULL;
    return novo;
}

int busca(No* raiz, int valor) {
    if (!raiz) return 0;

    if (valor == raiz->chave[0]) return 1;
    if (raiz->n == 2 && valor == raiz->chave[1]) return 1;

    if (valor < raiz->chave[0])
        return busca(raiz->filho[0], valor);
    else if (raiz->n == 1 || valor < raiz->chave[1])
        return busca(raiz->filho[1], valor);
    else
        return busca(raiz->filho[2], valor);
}

No* insereRec(No* no, int valor, int* cresceu, int* promovido, No** novoFilho) {
    if (!no) {
        *cresceu = 1;
        *promovido = valor;
        *novoFilho = NULL;
        return NULL;
    }

    int pos;
    if (valor < no->chave[0]) pos = 0;
    else if (no->n == 1 || valor < no->chave[1]) pos = 1;
    else pos = 2;

    no->filho[pos] = insereRec(no->filho[pos], valor, cresceu, promovido, novoFilho);

    if (!(*cresceu)) return no;

    if (no->n == 1) {
        if (pos == 0) {
            no->chave[1] = no->chave[0];
            no->chave[0] = *promovido;
            no->filho[2] = no->filho[1];
            no->filho[1] = *novoFilho;
        } else {
            no->chave[1] = *promovido;
            no->filho[2] = *novoFilho;
        }
        no->n = 2;
        *cresceu = 0;
        return no;
    }

    int chaves[3];
    No* filhos[4];

    chaves[0] = no->chave[0];
    chaves[1] = no->chave[1];
    chaves[2] = *promovido;

    filhos[0] = no->filho[0];
    filhos[1] = no->filho[1];
    filhos[2] = no->filho[2];
    filhos[3] = *novoFilho;

    for (int i = 2; i > pos; i--) {
        chaves[i] = chaves[i - 1];
        filhos[i + 1] = filhos[i];
    }
    chaves[pos] = *promovido;
    filhos[pos + 1] = *novoFilho;

    *promovido = chaves[1];

    No* direito = criaNo(chaves[2], filhos[2], filhos[3]);

    no->n = 1;
    no->chave[0] = chaves[0];
    no->filho[0] = filhos[0];
    no->filho[1] = filhos[1];
    no->filho[2] = NULL;

    *novoFilho = direito;
    return no;
}

No* insere(No* raiz, int valor) {
    int cresceu, promovido;
    No* novoFilho;

    raiz = insereRec(raiz, valor, &cresceu, &promovido, &novoFilho);

    if (cresceu)
        return criaNo(promovido, raiz, novoFilho);

    return raiz;
}

void emOrdem(No* raiz) {
    if (!raiz) return;

    emOrdem(raiz->filho[0]);
    printf("%d ", raiz->chave[0]);
    emOrdem(raiz->filho[1]);

    if (raiz->n == 2) {
        printf("%d ", raiz->chave[1]);
        emOrdem(raiz->filho[2]);
    }
}

typedef struct Fila {
    No* no;
    struct Fila* prox;
} Fila;

void enfileira(Fila** ini, Fila** fim, No* no) {
    Fila* novo = (Fila*)malloc(sizeof(Fila));
    novo->no = no;
    novo->prox = NULL;
    if (*fim) (*fim)->prox = novo;
    else *ini = novo;
    *fim = novo;
}

No* desenfileira(Fila** ini, Fila** fim) {
    Fila* temp = *ini;
    No* no = temp->no;
    *ini = temp->prox;
    if (!*ini) *fim = NULL;
    free(temp);
    return no;
}

void imprimePorNivel(No* raiz) {
    if (!raiz) return;

    Fila *ini = NULL, *fim = NULL;
    enfileira(&ini, &fim, raiz);

    while (ini) {
        No* atual = desenfileira(&ini, &fim);

        if (atual->n == 1)
            printf("[%d] ", atual->chave[0]);
        else
            printf("[%d,%d] ", atual->chave[0], atual->chave[1]);

        for (int i = 0; i <= atual->n; i++)
            if (atual->filho[i])
                enfileira(&ini, &fim, atual->filho[i]);
    }
}

int main() {
    No* raiz = NULL;
    int opcao, valor;

    do {
        printf("\n1-Inserir\n2-Buscar\n3-Em Ordem\n4-Por Nivel\n0-Sair\n");
        scanf("%d", &opcao);

        switch (opcao) {
            case 1:
                scanf("%d", &valor);
                raiz = insere(raiz, valor);
                break;
            case 2:
                scanf("%d", &valor);
                printf(busca(raiz, valor) ? "Encontrado\n" : "Nao encontrado\n");
                break;
            case 3:
                emOrdem(raiz);
                printf("\n");
                break;
            case 4:
                imprimePorNivel(raiz);
                printf("\n");
                break;
        }
    } while (opcao != 0);

    return 0;
}
