#include <stdio.h>
#include <stdlib.h>

typedef struct No {
    int n;
    int chave[2];
    struct No *filho[3];
} No;

/* ===================== CRIAÇÃO ===================== */

No* criaNo(int chave, No* esq, No* dir) {
    No* novo = (No*)malloc(sizeof(No));
    novo->n = 1;
    novo->chave[0] = chave;
    novo->filho[0] = esq;
    novo->filho[1] = dir;
    novo->filho[2] = NULL;
    return novo;
}

int ehFolha(No* no) {
    return no->filho[0] == NULL;
}

/* ===================== BUSCA ===================== */

int busca(No* raiz, int valor) {
    if (!raiz) return 0;

    if (valor == raiz->chave[0]) return 1;
    if (raiz->n == 2 && valor == raiz->chave[1]) return 1;

    if (valor < raiz->chave[0])
        return busca(raiz->filho[0], valor);
    else if (raiz->n == 1 || valor < raiz->chave[1])
        return busca(raiz->filho[1], valor);
    else
        return busca(raiz->filho[2], valor);
}

/* ===================== INSERÇÃO ===================== */

No* insereRec(No* no, int valor, int* cresceu, int* promovido, No** novoFilho) {
    if (!no) {
        *cresceu = 1;
        *promovido = valor;
        *novoFilho = NULL;
        return NULL;
    }

    int pos;
    if (valor < no->chave[0]) pos = 0;
    else if (no->n == 1 || valor < no->chave[1]) pos = 1;
    else pos = 2;

    no->filho[pos] = insereRec(no->filho[pos], valor, cresceu, promovido, novoFilho);

    if (!(*cresceu)) return no;

    if (no->n == 1) {
        if (pos == 0) {
            no->chave[1] = no->chave[0];
            no->chave[0] = *promovido;
            no->filho[2] = no->filho[1];
            no->filho[1] = *novoFilho;
        } else {
            no->chave[1] = *promovido;
            no->filho[2] = *novoFilho;
        }
        no->n = 2;
        *cresceu = 0;
        return no;
    }

    int ch[3];
    No* f[4];

    ch[0] = no->chave[0];
    ch[1] = no->chave[1];
    ch[2] = *promovido;

    f[0] = no->filho[0];
    f[1] = no->filho[1];
    f[2] = no->filho[2];
    f[3] = *novoFilho;

    for (int i = 2; i > pos; i--) {
        ch[i] = ch[i - 1];
        f[i + 1] = f[i];
    }
    ch[pos] = *promovido;
    f[pos + 1] = *novoFilho;

    *promovido = ch[1];

    No* dir = criaNo(ch[2], f[2], f[3]);

    no->n = 1;
    no->chave[0] = ch[0];
    no->filho[0] = f[0];
    no->filho[1] = f[1];
    no->filho[2] = NULL;

    *novoFilho = dir;
    return no;
}

No* insere(No* raiz, int valor) {
    int cresceu, promovido;
    No* novoFilho;

    raiz = insereRec(raiz, valor, &cresceu, &promovido, &novoFilho);

    if (cresceu)
        return criaNo(promovido, raiz, novoFilho);

    return raiz;
}

/* ===================== REMOÇÃO ===================== */

void corrigeUnderflow(No** pai, int pos) {
    No* no = (*pai)->filho[pos];

    if (pos > 0 && (*pai)->filho[pos - 1]->n == 2) {
        No* irmao = (*pai)->filho[pos - 1];

        for (int i = no->n; i > 0; i--)
            no->chave[i] = no->chave[i - 1];

        no->chave[0] = (*pai)->chave[pos - 1];
        (*pai)->chave[pos - 1] = irmao->chave[irmao->n - 1];

        no->n++;
        irmao->n--;
        return;
    }

    if (pos < (*pai)->n && (*pai)->filho[pos + 1]->n == 2) {
        No* irmao = (*pai)->filho[pos + 1];

        no->chave[no->n++] = (*pai)->chave[pos];
        (*pai)->chave[pos] = irmao->chave[0];

        irmao->chave[0] = irmao->chave[1];
        irmao->n--;
        return;
    }

    int mergePos = (pos > 0) ? pos - 1 : pos;
    No* esq = (*pai)->filho[mergePos];
    No* dir = (*pai)->filho[mergePos + 1];

    esq->chave[esq->n++] = (*pai)->chave[mergePos];
    esq->chave[esq->n++] = dir->chave[0];

    (*pai)->n--;
    free(dir);
}

int removeRec(No** raiz, int valor) {
    if (!*raiz) return 0;

    No* no = *raiz;
    int pos;

    if (valor == no->chave[0]) pos = 0;
    else if (no->n == 2 && valor == no->chave[1]) pos = 1;
    else {
        if (valor < no->chave[0]) pos = 0;
        else if (no->n == 1 || valor < no->chave[1]) pos = 1;
        else pos = 2;

        removeRec(&no->filho[pos], valor);
        if (no->filho[pos] && no->filho[pos]->n == 0)
            corrigeUnderflow(raiz, pos);
        return 1;
    }

    if (!ehFolha(no)) {
        No* aux = no->filho[pos + 1];
        while (!ehFolha(aux))
            aux = aux->filho[0];

        no->chave[pos] = aux->chave[0];
        removeRec(&no->filho[pos + 1], aux->chave[0]);
        if (no->filho[pos + 1]->n == 0)
            corrigeUnderflow(raiz, pos + 1);
        return 1;
    }

    for (int i = pos; i < no->n - 1; i++)
        no->chave[i] = no->chave[i + 1];

    no->n--;
    return 1;
}

No* removeValor(No* raiz, int valor) {
    removeRec(&raiz, valor);

    if (raiz && raiz->n == 0) {
        No* nova = raiz->filho[0];
        free(raiz);
        return nova;
    }
    return raiz;
}

/* ===================== EXIBIÇÃO ===================== */

void emOrdem(No* raiz) {
    if (!raiz) return;
    emOrdem(raiz->filho[0]);
    printf("%d ", raiz->chave[0]);
    emOrdem(raiz->filho[1]);
    if (raiz->n == 2) {
        printf("%d ", raiz->chave[1]);
        emOrdem(raiz->filho[2]);
    }
}

/* ===== EXIBIÇÃO POR NÍVEL ===== */

typedef struct Fila {
    No* no;
    struct Fila* prox;
} Fila;

void enfileira(Fila** ini, Fila** fim, No* no) {
    Fila* novo = (Fila*)malloc(sizeof(Fila));
    novo->no = no;
    novo->prox = NULL;
    if (*fim) (*fim)->prox = novo;
    else *ini = novo;
    *fim = novo;
}

No* desenfileira(Fila** ini, Fila** fim) {
    Fila* temp = *ini;
    No* no = temp->no;
    *ini = temp->prox;
    if (!*ini) *fim = NULL;
    free(temp);
    return no;
}

void imprimePorNivel(No* raiz) {
    if (!raiz) return;

    Fila *ini = NULL, *fim = NULL;
    enfileira(&ini, &fim, raiz);

    while (ini) {
        No* atual = desenfileira(&ini, &fim);

        if (atual->n == 1)
            printf("[%d] ", atual->chave[0]);
        else
            printf("[%d,%d] ", atual->chave[0], atual->chave[1]);

        for (int i = 0; i <= atual->n; i++)
            if (atual->filho[i])
                enfileira(&ini, &fim, atual->filho[i]);
    }
    printf("\n");
}

/* ===================== MENU ===================== */

int main() {
    No* raiz = NULL;
    int op, v;

    do {
        printf("\n1 Inserir\n2 Remover\n3 Buscar\n4 Em Ordem\n5 Por Nivel\n0 Sair\n");
        scanf("%d", &op);

        if (op == 1) {
            scanf("%d", &v);
            raiz = insere(raiz, v);
        } else if (op == 2) {
            scanf("%d", &v);
            raiz = removeValor(raiz, v);
        } else if (op == 3) {
            scanf("%d", &v);
            printf(busca(raiz, v) ? "Encontrado\n" : "Nao encontrado\n");
        } else if (op == 4) {
            emOrdem(raiz);
            printf("\n");
        } else if (op == 5) {
            imprimePorNivel(raiz);
        }
    } while (op != 0);

    return 0;
}
